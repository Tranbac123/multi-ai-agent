# Helm values for Multi-Tenant AIaaS Platform

# Global configuration
global:
  imageRegistry: "docker.io"
  imagePullSecrets: []
  storageClass: "fast-ssd"
  domain: "ai-platform.example.com"
  environment: "production"

# Image configuration
image:
  repository: "ai-platform"
  tag: "latest"
  pullPolicy: "IfNotPresent"

# Service configuration
service:
  type: "ClusterIP"
  port: 80
  targetPort: 8000

# Ingress configuration
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: "ai-platform.example.com"
      paths:
        - path: "/"
          pathType: "Prefix"
  tls:
    - secretName: "ai-platform-tls"
      hosts:
        - "ai-platform.example.com"

# Resource configuration
resources:
  limits:
    cpu: "1000m"
    memory: "2Gi"
  requests:
    cpu: "500m"
    memory: "1Gi"

# Autoscaling configuration
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# KEDA configuration
keda:
  enabled: true
  scalers:
    - name: "orchestrator-nats"
      type: "nats-jetstream"
      metadata:
        natsServerMonitoringEndpoint: "nats://nats:8222"
        stream: "orchestrator"
        consumer: "orchestrator-consumer"
        lagThreshold: "5"
      authentication:
        type: "none"
      triggers:
        - type: "nats-jetstream"
          metadata:
            lagThreshold: "5"
            activationLagThreshold: "10"
    - name: "ingestion-nats"
      type: "nats-jetstream"
      metadata:
        natsServerMonitoringEndpoint: "nats://nats:8222"
        stream: "ingestion"
        consumer: "ingestion-consumer"
        lagThreshold: "3"
      authentication:
        type: "none"
      triggers:
        - type: "nats-jetstream"
          metadata:
            lagThreshold: "3"
            activationLagThreshold: "8"

# Health check configuration
healthChecks:
  livenessProbe:
    httpGet:
      path: "/health"
      port: 8000
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    httpGet:
      path: "/health"
      port: 8000
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1

# Network policy configuration
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: "ingress-nginx"
        - namespaceSelector:
            matchLabels:
              name: "monitoring"
      ports:
        - protocol: "TCP"
          port: 8000
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: "database"
      ports:
        - protocol: "TCP"
          port: 5432
    - to:
        - namespaceSelector:
            matchLabels:
              name: "cache"
      ports:
        - protocol: "TCP"
          port: 6379
    - to:
        - namespaceSelector:
            matchLabels:
              name: "messaging"
      ports:
        - protocol: "TCP"
          port: 4222

# Security context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  capabilities:
    drop:
      - "ALL"
    add:
      - "NET_BIND_SERVICE"

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  seccompProfile:
    type: "RuntimeDefault"

# Service account
serviceAccount:
  create: true
  annotations: {}
  name: "ai-platform"

# RBAC configuration
rbac:
  create: true
  rules:
    - apiGroups: [""]
      resources: ["pods", "services", "endpoints"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["apps"]
      resources: ["deployments", "replicasets"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["autoscaling"]
      resources: ["horizontalpodautoscalers"]
      verbs: ["get", "list", "watch"]

# ConfigMap configuration
configMap:
  enabled: true
  data:
    LOG_LEVEL: "INFO"
    ENVIRONMENT: "production"
    DATABASE_URL: "postgresql://user:password@postgres:5432/ai_platform"
    REDIS_URL: "redis://redis:6379/0"
    NATS_URL: "nats://nats:4222"

# Secret configuration
secret:
  enabled: true
  data:
    DATABASE_PASSWORD: "base64_encoded_password"
    REDIS_PASSWORD: "base64_encoded_redis_password"
    NATS_PASSWORD: "base64_encoded_nats_password"
    JWT_SECRET: "base64_encoded_jwt_secret"

# Persistent volume configuration
persistence:
  enabled: false
  storageClass: "fast-ssd"
  accessMode: "ReadWriteOnce"
  size: "10Gi"

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: "app"
                operator: "In"
                values: ["ai-platform"]
          topologyKey: "kubernetes.io/hostname"

# Pod disruption budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  maxUnavailable: 1

# Horizontal Pod Autoscaler
hpa:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: "Percent"
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: "Percent"
          value: 50
          periodSeconds: 60

# Vertical Pod Autoscaler
vpa:
  enabled: false
  updatePolicy: "Auto"
  resourcePolicy:
    cpu:
      min: "100m"
      max: "2000m"
    memory:
      min: "128Mi"
      max: "4Gi"

# Monitoring configuration
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: "30s"
    scrapeTimeout: "10s"
    labels:
      app: "ai-platform"
  prometheusRule:
    enabled: true
    rules:
      - alert: "HighErrorRate"
        expr: "rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) > 0.05"
        for: "2m"
        labels:
          severity: "critical"
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }} for service {{ $labels.service }}"

# Logging configuration
logging:
  enabled: true
  level: "INFO"
  format: "json"
  output: "stdout"

# Tracing configuration
tracing:
  enabled: true
  jaeger:
    endpoint: "http://jaeger:14268/api/traces"
    serviceName: "ai-platform"
    sampler:
      type: "const"
      param: 1

# Metrics configuration
metrics:
  enabled: true
  port: 8080
  path: "/metrics"
  interval: "30s"

# Environment variables
env:
  - name: "LOG_LEVEL"
    value: "INFO"
  - name: "ENVIRONMENT"
    value: "production"
  - name: "DATABASE_URL"
    valueFrom:
      secretKeyRef:
        name: "ai-platform-secret"
        key: "DATABASE_URL"
  - name: "REDIS_URL"
    valueFrom:
      secretKeyRef:
        name: "ai-platform-secret"
        key: "REDIS_URL"
  - name: "NATS_URL"
    valueFrom:
      secretKeyRef:
        name: "ai-platform-secret"
        key: "NATS_URL"

# Init containers
initContainers:
  - name: "wait-for-dependencies"
    image: "busybox:1.35"
    command:
      - "sh"
      - "-c"
      - |
        until nc -z postgres 5432; do
          echo "Waiting for PostgreSQL..."
          sleep 2
        done
        until nc -z redis 6379; do
          echo "Waiting for Redis..."
          sleep 2
        done
        until nc -z nats 4222; do
          echo "Waiting for NATS..."
          sleep 2
        done
        echo "All dependencies are ready!"

# Sidecar containers
sidecarContainers:
  - name: "log-shipper"
    image: "fluent/fluent-bit:2.0"
    volumeMounts:
      - name: "fluent-bit-config"
        mountPath: "/fluent-bit/etc/"
    env:
      - name: "FLUENT_BIT_CONFIG"
        value: "/fluent-bit/etc/fluent-bit.conf"

# Volumes
volumes:
  - name: "fluent-bit-config"
    configMap:
      name: "fluent-bit-config"
  - name: "tmp"
    emptyDir: {}

# Volume mounts
volumeMounts:
  - name: "tmp"
    mountPath: "/tmp"